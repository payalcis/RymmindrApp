{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nexport function parseWebFontRules(clonedNode) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      if (!clonedNode.ownerDocument) {\n        reject(new Error('Provided element is not within a Document'));\n      }\n\n      resolve(toArray(clonedNode.ownerDocument.styleSheets));\n    }).then(getCssRules).then(getWebFontRules);\n  });\n}\nexport function embedWebFonts(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return parseWebFontRules(clonedNode).then(rules => Promise.all(rules.map(rule => {\n      const baseUrl = rule.parentStyleSheet ? rule.parentStyleSheet.href : null;\n      return embedResources(rule.cssText, baseUrl, options);\n    }))).then(cssStrings => cssStrings.join('\\n')).then(cssString => {\n      const styleNode = document.createElement('style');\n      const sytleContent = document.createTextNode(cssString);\n      styleNode.appendChild(sytleContent);\n\n      if (clonedNode.firstChild) {\n        clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n      } else {\n        clonedNode.appendChild(styleNode);\n      }\n\n      return clonedNode;\n    });\n  });\n}\nexport function getCssRules(styleSheets) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const ret = [];\n    const promises = []; // First loop inlines imports\n\n    styleSheets.forEach(sheet => {\n      if ('cssRules' in sheet) {\n        try {\n          toArray(sheet.cssRules).forEach(item => {\n            if (item.type === CSSRule.IMPORT_RULE) {\n              promises.push(fetchCSS(item.href, sheet).then(embedFonts).then(cssText => {\n                const parsed = parseCSS(cssText);\n                parsed.forEach(rule => {\n                  sheet.insertRule(rule, sheet.cssRules.length);\n                });\n              }).catch(e => {\n                console.log('Error loading remote css', e.toString());\n              }));\n            }\n          });\n        } catch (e) {\n          const inline = styleSheets.find(a => a.href === null) || document.styleSheets[0];\n\n          if (sheet.href != null) {\n            promises.push(fetchCSS(sheet.href, inline).then(embedFonts).then(cssText => {\n              const parsed = parseCSS(cssText);\n              parsed.forEach(rule => {\n                inline.insertRule(rule, sheet.cssRules.length);\n              });\n            }).catch(e => {\n              console.log('Error loading remote stylesheet', e.toString());\n            }));\n          }\n\n          console.log('Error inlining remote css file', e.toString());\n        }\n      }\n    });\n    return Promise.all(promises).then(() => {\n      // Second loop parses rules\n      styleSheets.forEach(sheet => {\n        if ('cssRules' in sheet) {\n          try {\n            toArray(sheet.cssRules).forEach(item => {\n              ret.push(item);\n            });\n          } catch (e) {\n            console.log(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n          }\n        }\n      });\n      return ret;\n    });\n  });\n}\n\nfunction getWebFontRules(cssRules) {\n  return cssRules.filter(rule => rule.type === CSSRule.FONT_FACE_RULE).filter(rule => shouldEmbed(rule.style.getPropertyValue('src')));\n}\n\nfunction parseCSS(source) {\n  if (source === undefined) {\n    return [];\n  }\n\n  let cssText = source;\n  const css = [];\n  const cssKeyframeRegex = '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})';\n  const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' + '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // to match css & media queries together\n\n  const cssCommentsRegex = new RegExp('(\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)', 'gi'); // strip out comments\n\n  cssText = cssText.replace(cssCommentsRegex, '');\n  const keyframesRegex = new RegExp(cssKeyframeRegex, 'gi');\n  let arr;\n\n  while (true) {\n    arr = keyframesRegex.exec(cssText);\n\n    if (arr === null) {\n      break;\n    }\n\n    css.push(arr[0]);\n  }\n\n  cssText = cssText.replace(keyframesRegex, ''); // unified regex\n\n  const unified = new RegExp(combinedCSSRegex, 'gi');\n\n  while (true) {\n    arr = unified.exec(cssText);\n\n    if (arr === null) {\n      break;\n    }\n\n    css.push(arr[0]);\n  }\n\n  return css;\n}\n\nfunction fetchCSS(url, sheet) {\n  return fetch(url).then(res => {\n    return {\n      url,\n      cssText: res.text()\n    };\n  }, e => {\n    console.log('ERROR FETCHING CSS: ', e.toString());\n  });\n}\n\nfunction embedFonts(data) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return data.cssText.then(resolved => {\n      let cssText = resolved;\n      const regexUrlFind = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n      const fontLocations = cssText.match(/url\\([^)]+\\)/g) || [];\n      const fontLoadedPromises = fontLocations.map(location => {\n        let url = location.replace(regexUrlFind, '$1');\n\n        if (!url.startsWith('https://')) {\n          const source = data.url;\n          url = new URL(url, source).href;\n        }\n\n        return new Promise((resolve, reject) => {\n          fetch(url).then(res => res.blob()).then(blob => {\n            const reader = new FileReader();\n            reader.addEventListener('load', res => {\n              // Side Effect\n              cssText = cssText.replace(location, `url(${reader.result})`);\n              resolve([location, reader.result]);\n            });\n            reader.readAsDataURL(blob);\n          }).catch(reject);\n        });\n      });\n      return Promise.all(fontLoadedPromises).then(() => cssText);\n    });\n  });\n}","map":{"version":3,"sources":["../src/embedWebFonts.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { toArray } from './util';\nimport { shouldEmbed, embedResources } from './embedResources';\nexport function parseWebFontRules(clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            if (!clonedNode.ownerDocument) {\n                reject(new Error('Provided element is not within a Document'));\n            }\n            resolve(toArray(clonedNode.ownerDocument.styleSheets));\n        })\n            .then(getCssRules)\n            .then(getWebFontRules);\n    });\n}\nexport function embedWebFonts(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return parseWebFontRules(clonedNode)\n            .then((rules) => Promise.all(rules.map((rule) => {\n            const baseUrl = rule.parentStyleSheet\n                ? rule.parentStyleSheet.href\n                : null;\n            return embedResources(rule.cssText, baseUrl, options);\n        })))\n            .then((cssStrings) => cssStrings.join('\\n'))\n            .then((cssString) => {\n            const styleNode = document.createElement('style');\n            const sytleContent = document.createTextNode(cssString);\n            styleNode.appendChild(sytleContent);\n            if (clonedNode.firstChild) {\n                clonedNode.insertBefore(styleNode, clonedNode.firstChild);\n            }\n            else {\n                clonedNode.appendChild(styleNode);\n            }\n            return clonedNode;\n        });\n    });\n}\nexport function getCssRules(styleSheets) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const ret = [];\n        const promises = [];\n        // First loop inlines imports\n        styleSheets.forEach((sheet) => {\n            if ('cssRules' in sheet) {\n                try {\n                    toArray(sheet.cssRules).forEach((item) => {\n                        if (item.type === CSSRule.IMPORT_RULE) {\n                            promises.push(fetchCSS(item.href, sheet)\n                                .then(embedFonts)\n                                .then((cssText) => {\n                                const parsed = parseCSS(cssText);\n                                parsed.forEach((rule) => {\n                                    sheet.insertRule(rule, sheet.cssRules.length);\n                                });\n                            })\n                                .catch((e) => {\n                                console.log('Error loading remote css', e.toString());\n                            }));\n                        }\n                    });\n                }\n                catch (e) {\n                    const inline = styleSheets.find((a) => a.href === null) || document.styleSheets[0];\n                    if (sheet.href != null) {\n                        promises.push(fetchCSS(sheet.href, inline)\n                            .then(embedFonts)\n                            .then((cssText) => {\n                            const parsed = parseCSS(cssText);\n                            parsed.forEach((rule) => {\n                                inline.insertRule(rule, sheet.cssRules.length);\n                            });\n                        })\n                            .catch((e) => {\n                            console.log('Error loading remote stylesheet', e.toString());\n                        }));\n                    }\n                    console.log('Error inlining remote css file', e.toString());\n                }\n            }\n        });\n        return Promise.all(promises).then(() => {\n            // Second loop parses rules\n            styleSheets.forEach((sheet) => {\n                if ('cssRules' in sheet) {\n                    try {\n                        toArray(sheet.cssRules).forEach((item) => {\n                            ret.push(item);\n                        });\n                    }\n                    catch (e) {\n                        console.log(`Error while reading CSS rules from ${sheet.href}`, e.toString());\n                    }\n                }\n            });\n            return ret;\n        });\n    });\n}\nfunction getWebFontRules(cssRules) {\n    return cssRules\n        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)\n        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));\n}\nfunction parseCSS(source) {\n    if (source === undefined) {\n        return [];\n    }\n    let cssText = source;\n    const css = [];\n    const cssKeyframeRegex = '((@.*?keyframes [\\\\s\\\\S]*?){([\\\\s\\\\S]*?}\\\\s*?)})';\n    const combinedCSSRegex = '((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]' +\n        '*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})'; // to match css & media queries together\n    const cssCommentsRegex = new RegExp('(\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)', 'gi');\n    // strip out comments\n    cssText = cssText.replace(cssCommentsRegex, '');\n    const keyframesRegex = new RegExp(cssKeyframeRegex, 'gi');\n    let arr;\n    while (true) {\n        arr = keyframesRegex.exec(cssText);\n        if (arr === null) {\n            break;\n        }\n        css.push(arr[0]);\n    }\n    cssText = cssText.replace(keyframesRegex, '');\n    // unified regex\n    const unified = new RegExp(combinedCSSRegex, 'gi');\n    while (true) {\n        arr = unified.exec(cssText);\n        if (arr === null) {\n            break;\n        }\n        css.push(arr[0]);\n    }\n    return css;\n}\nfunction fetchCSS(url, sheet) {\n    return fetch(url).then((res) => {\n        return {\n            url,\n            cssText: res.text(),\n        };\n    }, (e) => {\n        console.log('ERROR FETCHING CSS: ', e.toString());\n    });\n}\nfunction embedFonts(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return data.cssText.then((resolved) => {\n            let cssText = resolved;\n            const regexUrlFind = /url\\([\"']?([^\"')]+)[\"']?\\)/g;\n            const fontLocations = cssText.match(/url\\([^)]+\\)/g) || [];\n            const fontLoadedPromises = fontLocations.map((location) => {\n                let url = location.replace(regexUrlFind, '$1');\n                if (!url.startsWith('https://')) {\n                    const source = data.url;\n                    url = new URL(url, source).href;\n                }\n                return new Promise((resolve, reject) => {\n                    fetch(url)\n                        .then((res) => res.blob())\n                        .then((blob) => {\n                        const reader = new FileReader();\n                        reader.addEventListener('load', (res) => {\n                            // Side Effect\n                            cssText = cssText.replace(location, `url(${reader.result})`);\n                            resolve([location, reader.result]);\n                        });\n                        reader.readAsDataURL(blob);\n                    })\n                        .catch(reject);\n                });\n            });\n            return Promise.all(fontLoadedPromises).then(() => cssText);\n        });\n    });\n}\n//# sourceMappingURL=embedWebFonts.js.map"]},"metadata":{},"sourceType":"module"}