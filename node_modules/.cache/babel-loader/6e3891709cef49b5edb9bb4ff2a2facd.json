{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { embedResources } from './embedResources';\nimport { toArray, isDataUrl, toDataURL, getMimeType } from './util';\nexport function embedImages(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!(clonedNode instanceof Element)) {\n      return Promise.resolve(clonedNode);\n    }\n\n    return Promise.resolve(clonedNode).then(node => embedBackground(node, options)).then(node => embedImageNode(node, options)).then(node => embedChildren(node, options));\n  });\n}\n\nfunction embedBackground(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const background = clonedNode.style.getPropertyValue('background');\n\n    if (!background) {\n      return Promise.resolve(clonedNode);\n    }\n\n    return Promise.resolve(background).then(cssString => embedResources(cssString, null, options)).then(cssString => {\n      clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));\n      return clonedNode;\n    });\n  });\n}\n\nfunction embedImageNode(clonedNode, options) {\n  if (!(clonedNode instanceof HTMLImageElement) || isDataUrl(clonedNode.src)) {\n    return Promise.resolve(clonedNode);\n  }\n\n  return Promise.resolve(clonedNode.src).then(url => getBlobFromURL(url, options)).then(data => toDataURL(data, getMimeType(clonedNode.src))).then(dataURL => new Promise((resolve, reject) => {\n    clonedNode.onload = resolve;\n    clonedNode.onerror = reject;\n    clonedNode.src = dataURL;\n  })).then(() => clonedNode, () => clonedNode);\n}\n\nfunction embedChildren(clonedNode, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const children = toArray(clonedNode.childNodes);\n    const deferreds = children.map(child => embedImages(child, options));\n    return Promise.all(deferreds).then(() => clonedNode);\n  });\n}","map":{"version":3,"sources":["../src/embedImages.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,cAAT,QAA+B,kBAA/B;AACA,SAAS,OAAT,EAAkB,SAAlB,EAA6B,SAA7B,EAAwC,WAAxC,QAA2D,QAA3D;AAEA,OAAM,SAAgB,WAAhB,CACJ,UADI,EAEJ,OAFI,EAEW;;AAEf,QAAI,EAAE,UAAU,YAAY,OAAxB,CAAJ,EAAsC;AACpC,aAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,CAAP;AACD;;AAED,WAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,EACJ,IADI,CACE,IAAD,IAAU,eAAe,CAAC,IAAD,EAAO,OAAP,CAD1B,EAEJ,IAFI,CAEE,IAAD,IAAU,cAAc,CAAC,IAAD,EAAO,OAAP,CAFzB,EAGJ,IAHI,CAGE,IAAD,IAAU,aAAa,CAAC,IAAD,EAAO,OAAP,CAHxB,CAAP;AAID,G;AAAA;;AAED,SAAe,eAAf,CACE,UADF,EAEE,OAFF,EAEkB;;AAEhB,UAAM,UAAU,GAAG,UAAU,CAAC,KAAX,CAAiB,gBAAjB,CAAkC,YAAlC,CAAnB;;AACA,QAAI,CAAC,UAAL,EAAiB;AACf,aAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,CAAP;AACD;;AAED,WAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,EACJ,IADI,CACE,SAAD,IAAe,cAAc,CAAC,SAAD,EAAY,IAAZ,EAAkB,OAAlB,CAD9B,EAEJ,IAFI,CAEE,SAAD,IAAc;AAClB,MAAA,UAAU,CAAC,KAAX,CAAiB,WAAjB,CACE,YADF,EAEE,SAFF,EAGE,UAAU,CAAC,KAAX,CAAiB,mBAAjB,CAAqC,YAArC,CAHF;AAMA,aAAO,UAAP;AACD,KAVI,CAAP;AAWD,G;AAAA;;AAED,SAAS,cAAT,CACE,UADF,EAEE,OAFF,EAEkB;AAEhB,MAAI,EAAE,UAAU,YAAY,gBAAxB,KAA6C,SAAS,CAAC,UAAU,CAAC,GAAZ,CAA1D,EAA4E;AAC1E,WAAO,OAAO,CAAC,OAAR,CAAgB,UAAhB,CAAP;AACD;;AAED,SAAO,OAAO,CAAC,OAAR,CAAgB,UAAU,CAAC,GAA3B,EACJ,IADI,CACE,GAAD,IAAS,cAAc,CAAC,GAAD,EAAM,OAAN,CADxB,EAEJ,IAFI,CAEE,IAAD,IAAU,SAAS,CAAC,IAAD,EAAQ,WAAW,CAAC,UAAU,CAAC,GAAZ,CAAnB,CAFpB,EAGJ,IAHI,CAIF,OAAD,IACE,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AAC9B,IAAA,UAAU,CAAC,MAAX,GAAoB,OAApB;AACA,IAAA,UAAU,CAAC,OAAX,GAAqB,MAArB;AACA,IAAA,UAAU,CAAC,GAAX,GAAiB,OAAjB;AACD,GAJD,CALC,EAWJ,IAXI,CAYH,MAAM,UAZH,EAaH,MAAM,UAbH,CAAP;AAeD;;AAED,SAAe,aAAf,CACE,UADF,EAEE,OAFF,EAEiB;;AAEf,UAAM,QAAQ,GAAG,OAAO,CAAc,UAAU,CAAC,UAAzB,CAAxB;AACA,UAAM,SAAS,GAAG,QAAQ,CAAC,GAAT,CAAc,KAAD,IAAW,WAAW,CAAC,KAAD,EAAQ,OAAR,CAAnC,CAAlB;AAEA,WAAO,OAAO,CAAC,GAAR,CAAY,SAAZ,EAAuB,IAAvB,CAA4B,MAAM,UAAlC,CAAP;AACD,G;AAAA","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getBlobFromURL } from './getBlobFromURL';\nimport { embedResources } from './embedResources';\nimport { toArray, isDataUrl, toDataURL, getMimeType } from './util';\nexport function embedImages(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(clonedNode)\n            .then((node) => embedBackground(node, options))\n            .then((node) => embedImageNode(node, options))\n            .then((node) => embedChildren(node, options));\n    });\n}\nfunction embedBackground(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const background = clonedNode.style.getPropertyValue('background');\n        if (!background) {\n            return Promise.resolve(clonedNode);\n        }\n        return Promise.resolve(background)\n            .then((cssString) => embedResources(cssString, null, options))\n            .then((cssString) => {\n            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));\n            return clonedNode;\n        });\n    });\n}\nfunction embedImageNode(clonedNode, options) {\n    if (!(clonedNode instanceof HTMLImageElement) || isDataUrl(clonedNode.src)) {\n        return Promise.resolve(clonedNode);\n    }\n    return Promise.resolve(clonedNode.src)\n        .then((url) => getBlobFromURL(url, options))\n        .then((data) => toDataURL(data, getMimeType(clonedNode.src)))\n        .then((dataURL) => new Promise((resolve, reject) => {\n        clonedNode.onload = resolve;\n        clonedNode.onerror = reject;\n        clonedNode.src = dataURL;\n    }))\n        .then(() => clonedNode, () => clonedNode);\n}\nfunction embedChildren(clonedNode, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = toArray(clonedNode.childNodes);\n        const deferreds = children.map((child) => embedImages(child, options));\n        return Promise.all(deferreds).then(() => clonedNode);\n    });\n}\n//# sourceMappingURL=embedImages.js.map"]},"metadata":{},"sourceType":"module"}