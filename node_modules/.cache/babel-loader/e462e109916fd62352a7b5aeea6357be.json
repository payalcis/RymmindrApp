{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, toArray } from './util';\n\nfunction cloneSingleNode(node) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (node instanceof HTMLCanvasElement) {\n      const dataURL = node.toDataURL();\n\n      if (dataURL === 'data:,') {\n        return Promise.resolve(node.cloneNode(false));\n      }\n\n      return createImage(dataURL);\n    } // if (node.tagName && node.tagName.toLowerCase() === 'svg') {\n    //   return Promise.resolve(node as SVGElement)\n    //     .then((svg) => svgToDataURL(svg))\n    //     .then(createImage)\n    // }\n\n\n    return Promise.resolve(node.cloneNode(false));\n  });\n}\n\nfunction cloneChildren(nativeNode, clonedNode, filter) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const children = toArray(nativeNode.childNodes);\n\n    if (children.length === 0) {\n      return Promise.resolve(clonedNode);\n    }\n\n    return children.reduce((done, child) => done.then(() => cloneNode(child, filter)).then(clonedChild => {\n      if (clonedChild) {\n        clonedNode.appendChild(clonedChild);\n      }\n    }), Promise.resolve()).then(() => clonedNode);\n  });\n}\n\nfunction decorate(nativeNode, clonedNode) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!(clonedNode instanceof Element)) {\n      return clonedNode;\n    }\n\n    return Promise.resolve().then(() => cloneCssStyle(nativeNode, clonedNode)).then(() => clonePseudoElements(nativeNode, clonedNode)).then(() => cloneInputValue(nativeNode, clonedNode)).then(() => clonedNode);\n  });\n}\n\nfunction cloneCssStyle(nativeNode, clonedNode) {\n  const source = window.getComputedStyle(nativeNode);\n  const target = clonedNode.style;\n\n  if (source.cssText) {\n    target.cssText = source.cssText;\n  } else {\n    toArray(source).forEach(name => {\n      target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n    });\n  }\n}\n\nfunction cloneInputValue(nativeNode, clonedNode) {\n  if (nativeNode instanceof HTMLTextAreaElement) {\n    clonedNode.innerHTML = nativeNode.value;\n  }\n\n  if (nativeNode instanceof HTMLInputElement) {\n    clonedNode.setAttribute('value', nativeNode.value);\n  }\n}\n\nexport function cloneNode(nativeNode, filter, isRoot) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!isRoot && filter && !filter(nativeNode)) {\n      return Promise.resolve(null);\n    }\n\n    return Promise.resolve(nativeNode).then(cloneSingleNode).then(clonedNode => cloneChildren(nativeNode, clonedNode, filter)).then(clonedNode => decorate(nativeNode, clonedNode));\n  });\n}","map":{"version":3,"sources":["../src/cloneNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { clonePseudoElements } from './clonePseudoElements';\nimport { createImage, toArray } from './util';\nfunction cloneSingleNode(node) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (node instanceof HTMLCanvasElement) {\n            const dataURL = node.toDataURL();\n            if (dataURL === 'data:,') {\n                return Promise.resolve(node.cloneNode(false));\n            }\n            return createImage(dataURL);\n        }\n        // if (node.tagName && node.tagName.toLowerCase() === 'svg') {\n        //   return Promise.resolve(node as SVGElement)\n        //     .then((svg) => svgToDataURL(svg))\n        //     .then(createImage)\n        // }\n        return Promise.resolve(node.cloneNode(false));\n    });\n}\nfunction cloneChildren(nativeNode, clonedNode, filter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const children = toArray(nativeNode.childNodes);\n        if (children.length === 0) {\n            return Promise.resolve(clonedNode);\n        }\n        return children\n            .reduce((done, child) => done\n            .then(() => cloneNode(child, filter))\n            .then((clonedChild) => {\n            if (clonedChild) {\n                clonedNode.appendChild(clonedChild);\n            }\n        }), Promise.resolve())\n            .then(() => clonedNode);\n    });\n}\nfunction decorate(nativeNode, clonedNode) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!(clonedNode instanceof Element)) {\n            return clonedNode;\n        }\n        return Promise.resolve()\n            .then(() => cloneCssStyle(nativeNode, clonedNode))\n            .then(() => clonePseudoElements(nativeNode, clonedNode))\n            .then(() => cloneInputValue(nativeNode, clonedNode))\n            .then(() => clonedNode);\n    });\n}\nfunction cloneCssStyle(nativeNode, clonedNode) {\n    const source = window.getComputedStyle(nativeNode);\n    const target = clonedNode.style;\n    if (source.cssText) {\n        target.cssText = source.cssText;\n    }\n    else {\n        toArray(source).forEach((name) => {\n            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));\n        });\n    }\n}\nfunction cloneInputValue(nativeNode, clonedNode) {\n    if (nativeNode instanceof HTMLTextAreaElement) {\n        clonedNode.innerHTML = nativeNode.value;\n    }\n    if (nativeNode instanceof HTMLInputElement) {\n        clonedNode.setAttribute('value', nativeNode.value);\n    }\n}\nexport function cloneNode(nativeNode, filter, isRoot) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!isRoot && filter && !filter(nativeNode)) {\n            return Promise.resolve(null);\n        }\n        return Promise.resolve(nativeNode)\n            .then(cloneSingleNode)\n            .then((clonedNode) => cloneChildren(nativeNode, clonedNode, filter))\n            .then((clonedNode) => decorate(nativeNode, clonedNode));\n    });\n}\n//# sourceMappingURL=cloneNode.js.map"]},"metadata":{},"sourceType":"module"}